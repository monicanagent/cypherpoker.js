/**
* @file Defines a single WebRTC client (peer-to-peer connection) interface.
*
* @version 0.0.1
*/

/**
* @class A WebRTC client interface used to connect to and communicate
* with a single peer.
*/
class WebRTCClient extends EventDispatcher {

   //Event definitions:

   /**
   * The {@link createPeerConnection} function has successfully completed.
   *
   * @event WebRTCClient#create
   * @type {Event}
   */
   /**
   * An ICE candidate has been received from one of the STUN servers,
   *
   * @event WebRTCClient#icecandidate
   * @type {Event}
   * @property {RTCIceCandidate} candidate The received candidate.
   * @property {RTCSessionDescription} description The local session description including
   * the <code>candidate</code> data.
   */
   /**
   * A received offer generated by an initiating peer has been received, processed,
   * and an answer has been generated.
   *
   * @event WebRTCClient#offer
   * @type {Event}
   * @property {Object} offer The received offer as sent by the initiating peer.
   * @property {Object} answer The generated answer.
   */
   /**
   * A received answer generated by an responding peer has been received and processed.
   *
   * @event WebRTCClient#answer
   * @type {Event}
   * @property {Object} offer The initial offer.
   * @property {Object} answer The received answer generated by the responding peer.
   */
   /**
   * The data channel ({@link dataChannel}), created by the initiating peer has been created
   * locally. Note that this even will not be dispatched if this instance is the initiating peer.
   *
   * @event WebRTCClient#remotechannel
   * @type {Event}
   */
   /**
   * The data channel ({@link dataChannel}), has been successfully connected and
   * bi-directional communication can now take place (e.g. using the {@link sendMessage}
   * function).
   *
   * @event WebRTCClient#connect
   * @type {Event}
   */
   /**
   * The data channel ({@link dataChannel}), has disconnected.
   * function).
   *
   * @event WebRTCClient#disconnect
   * @type {Event}
   */
   /**
   * The data channel ({@link dataChannel}), has encountered an error.
   *
   * @event WebRTCClient#error
   * @type {Event}
   *
   * @property {Error} error The error reported by the data channel.
   */
   /**
   * The data channel ({@link dataChannel}), has received a message from a
   * connected peer.
   *
   * @event WebRTCClient#message
   * @type {Event}
   *
   * @property {*} message The received message.
   */
   constructor() {
      super();
   }

   /**
   * @property {Array|RTCIceServer} iceServers An indexed list of ICE/STUN servers
   * to use when creating a new connection.<br/>
   * Additional servers:<br/>
   * https://gist.github.com/zziuni/3741933
   * http://olegh.ftp.sh/public-stun.txt
   * https://gist.github.com/mondain/b0ec1cf5f60ae726202e
   * @readonly
   */
   get iceServers() {
      var serverList = [
         {urls:["stun.l.google.com:19302",
                "stun1.l.google.com:19302",
                "stun2.l.google.com:19302",
                "stun3.l.google.com:19302",
                "stun4.l.google.com:19302"]
         },
         {urls: "stunserver.org"},
         {urls:"stun.stunprotocol.org:3478"}
      ]
   }

   /**
   * @property {Object} connectionConfig A <code>RTCPeerConnection</code> configuration
   * object used to configure the instance.
   * @readonly
   */
   get connectionConfig() {
      var config = new Object();
      config.iceServers = this.iceServers;
   }

   /**
   * @property {RTCPeerConnection} peerConnection The peer connection object being
   * used by this instance. This property is set either when {@link createPeerConnection}
   * is invoked or when {@link setRemoteDescription} is invoked. Returns <code>null</code>
   * if no connection object currently exists.
   * @readonly
   */
   get peerConnection() {
      if (this["_peerConnection"] == undefined) {
         this._peerConnection = null;
      }
      return (this._peerConnection);
   }

   /**
   * @property {String} channelName The default data channel name used by this
   * instance.
   * @readonly
   */
   get channelName() {
      return ("p2pchannel");
   }

   /**
   * @property {RTCDataChannel} dataChannel The main data channel used to communicate
   * with a connected peer. Returns <code>null</code> if no data channel has been established.
   * @readonly
   */
   get dataChannel() {
      if (this["_dataChannel"] == undefined) {
         this._dataChannel = null;
      }
      return (this._dataChannel);
   }

   /**
   * Adds the standard RTCDataChannel handlers to the {@link dataChannel} instance.
   *
   * @private
   */
   addChannelHandlers() {
      if (this.dataChannel == null) {
         throw (new Error("No data channel established to which to attach listeners."));
      }
      this.dataChannel._client = this;
      this.dataChannel.onopen = this.onChannelOpen;
      this.dataChannel.onclose = this.onChannelClose;
      this.dataChannel.onerror = this.onChannelError;
      this.dataChannel.onmessage  = this.onChannelMessage;
   }

   /**
   * Creates an initiating peer connection and associated data channel that can
   * be used for peer-to-peer communications.
   *
   * @param {Object} [config=null] A configuration object to use with the <code>RTCPeerConnection</code>
   * ({@link peerConnection}). If ommitted or <code>null</code>, the default {@link connectionConfig} is used.
   *
   * @return {Promise} The promise resolves with <code>true</code> if the peer connection was successfully
   * created otherwise it rejects with a standard error.
   * @fires WebRTCClient#create
   * @async
   */
   async createPeerConnection(config=null) {
      if (config == null) {
         config = this.connectionConfig;
      }
      this._peerConnection = new RTCPeerConnection(config); //create initiating connection
      this._peerConnection._client = this; //store reference for event handlers
      this._dataChannel = this.peerConnection.createDataChannel(this.channelName);
      this.addChannelHandlers(); //add handlers immediately since this is an initiating instance
      this.peerConnection.onicecandidate = this.onICECandidate;
      var offer = await this.peerConnection.createOffer();
      //now start gathering ICE candidates...
      this.peerConnection.setLocalDescription(offer);
      var event = new Event("create");
      this.dispatchEvent(event);
      return (true);
   }

   /**
   * Event handler invoked when an ICE candidate is received from a STUN server.
   *
   * @param {Event} event A <code>RTCPeerConnection</code> event object.
   *
   * @fires WebRTCClient#icecandidate
   * @private
   */
   onICECandidate(event) {
      if ((event["candidate"] != undefined) && (event["candidate"] != null)) {
          var wrtcClient = event.target._client;
          var newEvent = new Event("icecandidate");
          newEvent.candidate = event.candidate;
          newEvent.description = wrtcClient.peerConnection.localDescription;          
          wrtcClient.dispatchEvent(newEvent);
      }
   }

   /**
   * Sets the connection offer sent by an initiating peer and generates an answer.
   *
   * @param {Object|String} descData The offer description to use. If this is a string it's
   * converted to a valid JSON object first.
   *
   * @return {Promise} The promise resolves with the generated answer to return to the initiating peer,
   * or rejects with a standard error if something went wrong.
   *
   * @fires WebRTCClient#offer
   * @async
   */
   async setRemoteDescription(descData) {
      if (typeof(descData) == "string") {
         var description = new RTCSessionDescription(JSON.parse(descData));
      } else {
         description = new RTCSessionDescription(descData);
      }
      if (description.type == "offer") {
         this._peerConnection = new RTCPeerConnection(this.connectionConfig); //create responding connection
         this._peerConnection._client = this; //store reference for event handlers
         this.peerConnection.ondatachannel = this.onDataChannelEstablished; //use initiating data channel
         var result = await this.peerConnection.setRemoteDescription(description);
         var answer = await this.peerConnection.createAnswer();
         this.peerConnection.setLocalDescription(answer);
         var answDesc = this.peerConnection.localDescription;
         var event = new Event("offer");
         event.offer = description;
         event.answer = answDesc;
         this.dispatchEvent(event);
         return (answDesc);
      }
      throw (new Error("Remote description not an \"offer\" type."));
   }

   /**
   * Sets the connection answer sent by an responding peer (as generated by {@link setRemoteDescription}),
   * usually in response to an offer.
   *
   * @param {Object|String} answerData The answer description to use. If this is a string it's
   * converted to a valid JSON object first.
   *
   * @return {Promise} The promise resolves with <code>true</code> if the answer was accepted, otherwise
   * it rejects with a standard error object.
   *
   * @fires WebRTCClient#answer
   * @async
   */
   async setRemoteAnswer(answerData) {
      if (typeof(answerData) == "string") {
         var description = new RTCSessionDescription(JSON.parse(answerData));
      } else {
         description = new RTCSessionDescription(answerData);
      }
      if (description.type == "answer") {
          this.peerConnection.setRemoteDescription(description);
          var event = new Event("offer");
          event.offer = this.peerConnection.localDescription;
          event.answer = description;
          this.dispatchEvent(event);
          return (true);
      }
      throw (new Error("Remote description not an \"answer\" type."));
   }

   /**
   * Event handler invoked when the initiating peer's channel has been locally established.
   *
   * @param {Event} event A <code>RTCPeerConnection</code> event.
   *
   * @fires WebRTCClient#remotechannel
   * @private
   */
   onDataChannelEstablished(event) {
      var wrtcClient = event.target._client;
      wrtcClient._dataChannel = event.channel;
      wrtcClient.addChannelHandlers();
      var newEvent = new Event("remotechannel");
      wrtcClient.dispatchEvent(newEvent);
   }

   /**
   * Event handler invoked when the {@link dataChannel} connects.
   *
   * @param {Event} event A <code>RTCPeerConnection</code> event.
   *
   * @fires WebRTCClient#connect
   * @private
   */
   onChannelOpen(event) {
      var wrtcClient = event.target._client;
      if (event.target.readyState == "open") {
         var newEvent = new Event("connect");
         wrtcClient.dispatchEvent(newEvent);
      }
   }

   /**
   * Event handler invoked when the {@link dataChannel} disconnects.
   *
   * @param {Event} event A <code>RTCDataChannel</code> event.
   *
   * @fires WebRTCClient#disconnect
   * @private
   */
   onChannelClose(event) {
      var wrtcClient = event.target._client;
      var newEvent = new Event("disconnect");
      wrtcClient.dispatchEvent(newEvent);
   }

   /**
   * Event handler invoked when the {@link dataChannel} reports an error.
   *
   * @param {Event} event A <code>RTCDataChannel</code> event.
   *
   * @fires WebRTCClient#error
   * @private
   */
   onChannelError(event) {
      var wrtcClient = event.target._client;
      var newEvent = new Event("error");
      newEvent.error = new Error(event.message);
      wrtcClient.dispatchEvent(newEvent);
   }

   /**
   * Event handler invoked when the {@link dataChannel} receives a message
   * from a connected peer.
   *
   * @param {Event} event A <code>RTCDataChannel</code> event.
   *
   * @fires WebRTCClient#message
   * @private
   */
   onChannelMessage(event) {
      var wrtcClient = event.target._client;
      var newEvent = new Event("error");
      newEvent.message = event.data;
      wrtcClient.dispatchEvent(newEvent);
   }

   /**
   * Sends a peer-to-peer message to the connected peer.
   *
   * @param {String|Object} data The message to send. If the message is
   * not a string it is stringified into JSON string data.
   */
   sendMessage (data) {
      if (typeof(data) != "string") {
         data = JSON.stringify(data);
      }
      this.dataChannel.send(data);
   }

}
