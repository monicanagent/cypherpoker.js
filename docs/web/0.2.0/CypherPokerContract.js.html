<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CypherPokerContract.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CypherPokerContract.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* @file A virtual smart contract implementation using a WebSocket Session
* service as a TTP host.
*
* @version 0.2.0
* @author Patrick Bay
* @copyright MIT License
*/

/**
* @class A virtual smart contract interface for an associated {@link CypherPokerGame}
* instance. Communicates with a WebSocket Session TTP service instead of directly
* with a smart contract front-end.
*
* @extends EventDispatcher
*/
class CypherPokerContract extends EventDispatcher {

   /**
   * The contract timeout timer has been started or restarted.
   *
   * @event CypherPokerContract#timeoutstart
   * @type {Event}
   * @property {CypherPokerContract} contract The instance dispatching the event.
   * @property {Number} seconds The number of seconds that must elapse without
   * player activity before the contract times out.
   * @property {Number} cSeconds The number of courtesy seconds that will
   * be allowed to elapse before the contract's "timeout" function is
   * invoked. Note that the timeout may occur at any time after the contract
   * has timed out (hence "courtesy" seconds).
   */
   /**
   * The contract appears to have timed out due to player inactivity. This is a local event
   * and does not necessarily reflect the state of the actual contract.
   *
   * @event CypherPokerContract#timeout
   * @type {Event}
   * @property {CypherPokerContract} contract The instance dispatching the event.
   * @property {Array} penalized Array of objects containing private ID(s) and
   * the amount tahat the associated player(s) were penalized. Typically
   * only one player will time out (penalized[0]), but under certain
   * conditions more than one player may time out.
   */
   /**
   * The contract timeout is no longer valid (e.g. the game has ended).
   *
   * @event CypherPokerContract#timeoutinvalid
   * @type {Event}
   * @property {CypherPokerContract} contract The instance dispatching the event.
   */

   /**
   * Creates a new proxy contract instance.
   *
   * @param {CypherPokerGame} gameRef The active game instance with which
   * this contract interface is associated.
   */
   constructor(gameRef) {
      super();
      this._game = gameRef;
      this.addGameEventListeners();
   }

   /**
   * @property {CypherPokerGame} game Reference to the associated game for
   * which to act as contract handler.
   */
   get game() {
      return (this._game);
   }

   /**
   * @property {CypherPoker} cypherpoker A reference to the
   * {@link CypherPokerContract#game}'s &lt;code>cypherpoker&lt;/code> instance or
   * &lt;code>null&lt;/code> if none exists.
   */
   get cypherpoker() {
      if ((this._game != null) &amp;&amp; (this._game != undefined)) {
         return (this._game.cypherpoker);
      }
      return (null);
   }

   /**
   * @property {Boolean} ready=false Indicates whether or not the contract is
   * ready (has been successfully remotely created).
   */
   get ready() {
      if (this.contractID == null) {
         return (false);
      }
      //other validity tests can be done here
      return (true);
   }

   /**
   * @property {String} contractID=null The ID of the contract instance, usually
   * as returned by the remote contract host. If this is &lt;code>null&lt;/code>, this
   * instance should not be considered valid.
   */
   get contractID() {
      if (this._contractID == undefined) {
         this._contractID = null;
      }
      return (this._contractID);
   }

   /**
   * @property {Array} history=null Indexed array of external contract snapshots
   * with index 0 being the most recent.
   */
   get history() {
      if (this._history == undefined) {
         this._history = new Array();
      }
      return (this._history);
   }

   /**
   * @property {Array} deferredActions Indexed list of objects containing
   * game state &lt;code>snapshot&lt;/code>, &lt;code>invoke&lt;/code>, &lt;code>promise&lt;/code>,
   * parent &lt;code>contract&lt;/code>, and boolean &lt;code>complete&lt;/code> properties.
   */
   get deferredActions() {
      if (this._deferredActions == undefined) {
         this._deferredActions = new Array();
      }
      return (this._deferredActions);
   }

   /**
   * @property {Array} deferredPromises Complete indexed list of Promise instances currently
   * in the {@link CypherPokerContract#deferredActions} array.
   */
   get deferredPromises() {
      var returnArr = new Array();
      for (var count=0; count &lt; this.deferredActions.length; count++) {
         returnArr.push(this.deferredActions[count].promise);
      }
      return (returnArr);
   }

   /**
   * @property {Array} deferredActivePromises Indexed list of Promise instances currently
   * in the {@link CypherPokerContract#deferredActions} array which have the property:
   * &lt;code>complete == false&lt;/code>
   */
   get deferredActivePromises() {
      var returnArr = new Array();
      for (var count=0; count &lt; this.deferredActions.length; count++) {
         if (this.deferredActions[count].complete == false) {
            returnArr.push(this.deferredActions[count].promise);
         }
      }
      return (returnArr);
   }

   /**
   * Adds event listeners required by the contract handler to the associated
   * {@link CypherPokerContract#game} instance.
   *
   * @private
   */
   addGameEventListeners() {
      this.game.addEventListener("gamedeck", this.onNewGameDeck, this);
      this.game.addEventListener("gamecardsencrypt", this.onEncryptCards, this);
      this.game.addEventListener("gamedealprivate", this.onSelectCards, this);
      this.game.addEventListener("gamedealpublic", this.onSelectCards, this);
      this.game.addEventListener("gamedealmsg", this.onGameDeal, this);
      this.game.addEventListener("gamebetplaced", this.onGameBetPlaced, this);
      this.game.addEventListener("gamedecrypt", this.onGameDecrypt, this);
      this.game.addEventListener("gameend", this.onGameEnd, this);
      this.cypherpoker.p2p.addEventListener("update", this.handleUpdateMessage, this);
   }

   /**
   * Removes event listeners required by the contract handler from the associated
   * {@link CypherPokerContract#game} instance.
   *
   * @private
   */
   removeGameEventListeners() {
      this.game.removeEventListener("gamedeck", this.onNewGameDeck);
      this.game.removeEventListener("gamecardsencrypt", this.onEncryptCards);
      this.game.removeEventListener("gamedealprivate", this.onSelectCards);
      this.game.removeEventListener("gamedealpublic", this.onSelectCards);
      this.game.removeEventListener("gamedealmsg", this.onGameDeal);
      this.game.removeEventListener("gamebetplaced", this.onGameBetPlaced);
      this.game.removeEventListener("gamedecrypt", this.onGameDecrypt);
      this.game.removeEventListener("gameend", this.onGameEnd);
      this.cypherpoker.p2p.removeEventListener("update", this.handleUpdateMessage);
   }

   /**
   * Stops any current game timeout timer.
   * @private
   */
   stopContractTimeout() {
      try {
         clearTimeout(this._contractTimeoutID);
      } catch (err) {}
   }

   /**
   * Cancels and resets the current contract timeout, signalling any listeners
   * to ignore future timeout events from this instance.
   *
   * @fires CypherPokerContract#event:timeoutinvalid
   * @private
   */
   resetContractTimeout() {
      try {
         clearTimeout(this._contractTimeoutID);
      } catch (err) {}
      var event = new Event("timeoutinvalid");
      event.contract = this;
      this.dispatchEvent(event);
   }

   /**
   * Stops any current game timeout timer and starts a new one based on the
   * most recent contract (&lt;code>history[0]&lt;/code>).
   *
   * @fires CypherPokerContract#timeoutstart
   * @throws {Error} If the contract timeout could not be started.
   * @private
   */
   startContractTimeout() {
      this.stopContractTimeout();
      if ((this.history[0] == undefined) || (this.history[0] == null)) {
         return;
      }
      if (typeof(this.history[0].table.tableInfo.timeout) == "number") {
         //add 5 seconds to timeout to make sure we don't accidentally clock in early
         var timeout = (this.history[0].table.tableInfo.timeout + 5) * 1000;
         var event = new Event("timeoutstart");
         event.contract = this;
         event.seconds = this.history[0].table.tableInfo.timeout;
         event.cSeconds = 5;
         this.dispatchEvent(event);
         this._contractTimeoutID = setTimeout(this.onContractTimeout, timeout, this);
      } else {
         console.error ("Contract \""+this._contractID+"\" does not define a timeout. It may never complete!")
      }
   }

   /**
   * Called on a timer when a contract times out (one or more players
   * have failed to take an action in time).
   *
   * @private
   * @fires CypherPokerContract#timeout
   */
   onContractTimeout(contractInstance) {
      try {
         clearTimeout(contractInstance._contractTimeoutID);
         contractInstance._contractTimeoutID = null;
         delete contractInstance._contractTimeoutID;
      } catch (err) {
      } finally {
         var paramsObj = new Object();
         paramsObj.contract = contractInstance.history[0];
         paramsObj.contractID = paramsObj.contract.contractID;
         paramsObj.ownerPID = contractInstance.game.getDealer().privateID;
         var snapshot = contractInstance.gameSnapshot();
         //call "timeout" penalty
         contractInstance.callContractAPI("timeout", paramsObj).then(JSONResult => {
            if (JSONResult.error != undefined) {
               //probably already timed out
               //console.error(JSONResult.error);
               return;
            }
            if (contractInstance.contractID != JSONResult.result.contract.contractID) {
               console.error("Expecting contract ID \""+contractInstance.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
               console.dir(JSONResult);
               throw(new Error("Unexpected contract ID returned."));
            }
            contractInstance.history.unshift(JSONResult.result.contract);
            try {
               contractInstance.updateBalances(JSONResult.result.contract);
            } catch (err) {
               console.error(err);
            }
            //the game can either end here or start a re-key operation
         }).catch (err => {
            contractInstance.game.debug(err, "err");
         });
      }
   }

   /**
   * Creates a snapshot (copy) of the associated {@link CypherPokerContract#game} instance's
   * current data in the format of a contract data object for use as a condition in subsequent
   * contract actions.
   */
   gameSnapshot() {
      var snapshot = new Object();
      snapshot.players = this.game.getPlayers(false, false);
      snapshot.table = this.game.getTable();
      try {
         snapshot.prime = this.game.getPlayer(this.game.ownPID).keychain[0].prime;
      } catch (err) {
         snapshot.prime = null;
      }
      snapshot.cardDecks = this.game.getCardDecks();
      return (snapshot);
   }

   /**
   * Recursively compares two objects for matching properties.
   *
   * @param {Object} obj1 The first object to compare.
   * @param {Object} obj2 The second object to compare.
   *
   * @return {Boolean} True if all properties found in &lt;code>obj1&lt;/code> appear
   * in &lt;code>obj2&lt;/code>, false otherwise.
   * @private
   */
   compareObjects (obj1, obj2) {
      if ((obj1 == null) &amp;&amp; (obj2 == null)) {
         return (true);
      }
      var obj1Entries = Object.entries(obj1);
      for (var count=0; count &lt; obj1Entries.length; count++) {
         try {
            var key = obj1Entries[count][0];
            if (typeof(obj1[key]) == "object") {
               //recurse compare sub-objects
               if (this.compareObjects(obj1[key], obj2[key]) == false) {
                  return (false);
               }
            } else {
               //compare primitives
               if (obj1[key] != obj2[key]) {
                  if (key != "timeout") {
                     return (false);
                  }
               }
            }
         } catch (err) {
            console.error (err);
            return (false);
         }
      }
      return (true);
   }

   /**
   * Compares a contract data object to a game snapshot object.
   *
   * @param {Object} contract The (usually) external contract data object to compare.
   * @param {Object} snapshot The game snapshot object to compare to the &lt;code>contract&lt;/code>.
   * This object must have the same structure as the contract data object.
   *
   * @return (Number) If the &lt;code>contract&lt;/code> appears to be ahead of the snapshot 1
   * is returned. If the &lt;code>snapshot&lt;/code> appears to be ahead of the contract 2 is
   * returned. If the contract appears the same as the snapshot but not in the same order
   * (e.g. facedown cards), then 3 is returned. If both contract and snapshot are identical,
   * 0 is returned.
   * @throws {Error} If the expected structure or data of the parameters does not match.
   * @private
   */
   compare(contract, snapshot) {
      if (this.compareObjects(contract.table, snapshot.table) == false) {
         throw (new Error("Table properties don't match."));
      }
      if ((contract.prime != null) &amp;&amp; (snapshot.prime == null)) {
         return (1);
      } else if ((contract.prime == null) &amp;&amp; (snapshot.prime != null)) {
         return (2);
      } else if (contract.prime != snapshot.prime) {
         throw (new Error("Prime value mismatch."));
      }
      //compare decks
      result = this.compareDecks(contract.cardDecks.faceup, snapshot.cardDecks.faceup, "_mapping");
      if (result != 0) {
         return (result);
      }
      result = this.compareDecks(contract.cardDecks.facedown, snapshot.cardDecks.facedown);
      if (result != 0) {
         return (result);
      }
      result = this.compareDecks(contract.cardDecks.dealt, snapshot.cardDecks.dealt);
      if (result != 0) {
         return (result);
      }
      result = this.compareDecks(contract.cardDecks.public, snapshot.cardDecks.public, "_mapping");
      if (result != 0) {
         return (result);
      }
      //compare players
      for (var count = 0; count &lt; contract.players.length; count++) {
         var contractPlayer = contract.players[count];
         var snapshotPlayer = snapshot.players[count];
         if (contractPlayer.privateID != snapshotPlayer.privateID) {
            //player order must be the same
            console.error("Error 4");
            throw (new (Error("Incorrect player private ID at position "+count)));
         }
         for (var prop in contractPlayer.info) {
            if (snapshotPlayer.info[prop] != contractPlayer.info[prop]) {
               console.error("Error 5");
               throw (new (Error("Incorrect player private info property \""+prop+"\"")));
            }
         }
         //compare player dealt cards
         var result = this.compareDecks(contractPlayer.dealtCards, snapshotPlayer.dealtCards, "_mapping");
         if (result != 0) {
            return (result);
         }
         //compare player selected cards
         result = this.compareDecks(contractPlayer.selectedCards, snapshotPlayer.selectedCards);
         if (result != 0) {
            return (result);
         }
         if (contractPlayer.hasBet &amp;&amp; (snapshotPlayer.hasBet == false)) {
            return (1);
         } else if ((contractPlayer.hasBet == false) &amp;&amp; snapshotPlayer.hasBet) {
            return (2);
         }
         if (contractPlayer.hasFolded &amp;&amp; (snapshotPlayer.hasFolded == false)) {
            return (1);
         } else if ((contractPlayer.hasFolded == false) &amp;&amp; snapshotPlayer.hasFolded) {
            return (2);
         }
         if (contractPlayer.isDealer != snapshotPlayer.isDealer) {
            throw (new Error("Player role mismatch on dealer."));
         }
         if (contractPlayer.isSmallBlind != snapshotPlayer.isSmallBlind) {
            throw (new Error("Player role mismatch on small blind."));
         }
         if (contractPlayer.isBigBlind != snapshotPlayer.isBigBlind) {
            throw (new Error("Player role mismatch on big blind."));
         }
         if (contractPlayer.ready != snapshotPlayer.ready) {
            throw (new Error("Player ready mismatch."));
         }
         contractPlayer.totalBet = bigInt(contractPlayer.totalBet);
         snapshotPlayer.totalBet = bigInt(snapshotPlayer.totalBet);
         if (contractPlayer.totalBet.greater(snapshotPlayer.totalBet)) {
            return (1);
         } else if (snapshotPlayer.totalBet.greater(contractPlayer.totalBet)) {
            return (2);
         }
         //balance comparison is the inverse of totalBet comparison
         contractPlayer.balance = bigInt(contractPlayer.balance);
         snapshotPlayer.balance = bigInt(snapshotPlayer.balance);
         if (contractPlayer.balance.greater(snapshotPlayer.balance)) {
            return (2);
         } else if (snapshotPlayer.balance.greater(contractPlayer.balance)) {
            return (1);
         }
      }
      //relevant contract properties match snapshot properties
      return (0);
   }

   /**
   * Compares a contract card deck against a snapshot card deck.
   *
   * @param {Array} contractDeck Indexed list of contract cards to examine.
   * @param {Array} snapshotDeck Indexed list of snapshot cards to examine.
   * @param {String} [valueProp=null] If supplied, each deck's element is assumed
   * to be a complex object and this is its value property (e.g. &lt;code>mapping&lt;/code>).
   * If omitted or &lt;code>null&lt;/code>, elements are compared directly with each other.
   *
   * @return {Number} A 0 is returned if both decks are identical: same values and array
   * lengths (though their order may be different). A 1 is returned if the contract deck
   * has more elements than than the snapshot deck, and 2 is returned if the snapshot deck
   * has more elements than the contract deck.
   *
   * @throws {Error} Thrown when a deck contains one or more elements that should appear
   * in the other deck but don't, or if a deck contains duplicate elements.
   * @private
   */
   compareDecks(contractDeck, snapshotDeck, valueProp=null) {
      if (this.containsDuplicates(contractDeck, valueProp) == true) {
         throw (new Error("Contract deck contains duplicates."));
      }
      if (this.containsDuplicates(snapshotDeck, valueProp) == true) {
         throw (new Error("Snapshot deck contains duplicates."));
      }
      var numMatches = 0;
      contractDeck.forEach((value, index, arr) => {
         if (valueProp != null) {
            var contractValue = value[valueProp];
         } else {
            contractValue = value;
         }
         for (var count=0; count &lt; snapshotDeck.length; count++) {
            if (valueProp != null) {
               var snapshotValue = snapshotDeck[count][valueProp];
            } else {
               snapshotValue = snapshotDeck[count];
            }
            if (snapshotValue == contractValue) {
               numMatches++;
            }
         }
      }, this);
      if (contractDeck.length > snapshotDeck.length) {
         return (1);
      } else if (contractDeck.length &lt; snapshotDeck.length) {
         return (2);
      } else {
         if (numMatches != contractDeck.length) {
            //decks are same length but not all elements match
            throw (new Error("Mismatched deck elements."));
         }
         //decks are identical (no duplications, same length)
         return (0);
      }
   }

   /**
   * Checks a card deck array for duplicate values.
   *
   * @param {Array} cardDeck Indexed array of values to examine.
   * @param {String} [valueProp=null] The value property of each array
   * element to examine (e.g. &lt;code>mapping&lt;/code>). If omitted or &lt;code>null&lt;/code>,
   * each element is examined directly.
   *
   * @return {Boolean} True if the &lt;code>cardDeck&lt;/code> contains duplicate values,
   * otherwise false.
   * @private
   */
   containsDuplicates(cardDeck, valueProp=null) {
      var compareDeck = Array.from(cardDeck);
      var dupFound = false;
      cardDeck.forEach((value,index,arr) => {
         if (valueProp != null) {
            var cardValue = value[valueProp];
         } else {
            cardValue = value;
         }
         var matchCount = 0;
         compareDeck.forEach((cValue,cIndex,cArr) => {
            if (valueProp != null) {
               var compareValue = cValue[valueProp];
            } else {
               compareValue = cValue;
            }
            if (compareValue == cardValue) {
               matchCount++;
            }
            if (matchCount > 1) {
               dupFound = true;
            }
         });
      });
      return (dupFound);
   }

   /**
   * Event handler invoked a new game deck is fully generated. This triggers
   * the asynchronous creation and / or initialization of a new contract for
   * the game.
   *
   * @param {CypherPokerGame#event:gamedeck} event A "gamedeck" event.
   * @private
   */
   onNewGameDeck(event) {
      if (this.game.getDealer().privateID == this.game.ownPID) {
         //dealer creates the new contract; other players only agree to it
         var paramsObj = new Object();
         paramsObj.contract = new Object();
         //is there a better way to create the contract ID?
         this._contractID = String(Math.random()).split(".")[1];
         paramsObj.contract.contractID = this._contractID;
         paramsObj.contract.players = this.game.getPlayers(false, false);
         paramsObj.contract.table = this.game.table;
         paramsObj.contract.prime = this.game.getPlayer(this.game.ownPID).keychain[0].prime; //prime generated by us
         paramsObj.contract.cardDecks = this.game.cardDecks;
         paramsObj.contract.table.tableInfo.timeout = 20; //(seconds) this can be user-configured
         this.callContractAPI("new", paramsObj).then(JSONResult => {
            if (this.contractID != JSONResult.result.contract.contractID) {
               console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
               console.dir(JSONResult);
               throw(new Error("Unexpected contract ID returned."));
            }
            this.history.unshift(JSONResult.result.contract);
            try {
               this.updateBalances(JSONResult.result.contract);
            } catch (err) {
               console.error(err);
            }
         }).catch (err => {
            this.game.debug(err, "err");
         });
      } else {
         //not the dealer; do nothing
      }
   }

   /**
   * Event handler invoked a card encryption cycle happens. If this is ours,
   * it automatically triggers a contract "store" operation.
   *
   *
   * @param {CypherPokerGame#event:gamecardsencrypt} event A "gamecardsencrypt" event.
   *
   * @return {Promise} Resolves to &lt;code>true&lt;/code> if the store operation successfully completed. Rejections
   * receive an &lt;code>Error&lt;/code> object.
   * @private
   */
   async onEncryptCards(event) {
      if (event.player.privateID != this.game.ownPID) {
         return(false);
      }
      this.startContractTimeout();
      var paramsObj = new Object();
      paramsObj.type = "encrypt";
      paramsObj.contract = this.history[0];
      paramsObj.contractID = this._contractID;
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.cards = Array.from(event.selected);
      var snapshot = this.gameSnapshot();
      try {
         var JSONResult = await this.onGameState(snapshot, this.callContractAPI, "store", paramsObj).promise;
         if (JSONResult.error != undefined) {
            console.error(JSONResult.error.message);
            throw (new Error(JSONResult.error.message));
         }
         if (this.contractID != JSONResult.result.contract.contractID) {
            console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
            console.dir(JSONResult);
            throw(new Error("Unexpected contract ID returned."));
         }
         try {
            this.updateBalances(JSONResult.result.contract);
         } catch (err) {
            this.game.debug(err, "err");
         }
      } catch (err) {
         this.game.debug(err, "err");
      }
      return (true);
   }

   /**
   * Event handler invoked when the associated {@link CypherPokerContract#game}
   * instance{@link CypherPokerGame#event:gamedealprivate} or
   * {@link CypherPokerGame#event:gamedealpublic} event. This
   * it automatically triggers a contract "store" operation.
   *
   * @param {CypherPokerGame#event} event A{@link CypherPokerGame#event:gamedealprivate} or
   * {@link CypherPokerGame#event:gamedealpublic} event object.
   *
   * @async
   * @private
   */
   async onSelectCards(event) {
      this.startContractTimeout();
      var paramsObj = new Object();
      paramsObj.type = "select";
      paramsObj.contract = this.history[0];
      paramsObj.contractID = paramsObj.contract.contractID;
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.cards = Array.from(event.selected);
      paramsObj.fromPID = this.game.ownPID;
      if (event.type == "gamedealprivate") {
         paramsObj.private = true;
      } else {
         paramsObj.private = false;
      }
      var snapshot = this.gameSnapshot();
      try {
         var JSONResult = await this.onGameState(snapshot, this.callContractAPI, "store", paramsObj).promise;
         if (JSONResult.error != undefined) {
            console.error(JSON.error.message);
            throw(new Error(JSON.error.message));
         }
         if (this.contractID != JSONResult.result.contract.contractID) {
            console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
            console.dir(JSONResult);
            throw(new Error("Unexpected contract ID returned."));
         }
         try {
            this.updateBalances(JSONResult.result.contract);
         } catch (err) {
            this.game.debug(err, "err");
         }
      } catch (err) {
         this.game.debug(err, "err");
      }
      return (true);
   }

   /**
   * Event handler invoked when the associated {@link CypherPokerContract#game}
   * instance{@link CypherPokerGame#event:gamedealmsg} event.
   *
   * @param {CypherPokerGame#event:gamedealmsg} event An external deal operation
   * notification event.
   *
   * @private
   */
   onGameDeal(event) {
      this.startContractTimeout();
   }

   /**
   * Event handler invoked when the associated {@link CypherPokerContract#game}
   * instance{@link CypherPokerGame#event:gamebetplaced} event. This
   * it automatically triggers a contract "store" operation.
   *
   * @param {CypherPokerGame#event} event A {@link CypherPokerGame#event:gamebetplaced} event object.
   *
   * @async
   * @private
   */
   async onGameBetPlaced(event) {
      this.startContractTimeout();
      var paramsObj = new Object();
      paramsObj.contract = this.history[0];
      paramsObj.contractID = paramsObj.contract.contractID;
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.amount = event.amount;
      paramsObj.fromPID = this.game.ownPID;
      var snapshot = this.gameSnapshot();
      try {
         var JSONResult = await this.onGameState(snapshot, this.callContractAPI, "bet", paramsObj).promise;
         if (JSONResult.error != undefined) {
            console.error(JSONResult.error.message);
            throw(new Error(JSONResult.error.message));
         }
         if (this.contractID != JSONResult.result.contract.contractID) {
            console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
            console.dir(JSONResult);
            throw(new Error("Unexpected contract ID returned."));
         }
         try {
            this.updateBalances(JSONResult.result.contract);
         } catch (err) {
            this.game.debug(err, "err");
         }
      } catch (err) {
         this.game.debug(err, "err");
      }
      return (true);
   }

   /**
   * Event handler invoked when the associated {@link CypherPokerContract#game}
   * instance dispatches a {@link CypherPoker#event:gamedecrypt} event.
   *
   * @param {Event} event A {@link CypherPoker#event:gamedecrypt} event object.
   *
   * @async
   * @private
   */
   async onGameDecrypt(event) {
      this.startContractTimeout();
      var paramsObj = new Object();
      paramsObj.type = "decrypt";
      paramsObj.contract = this.history[0];
      paramsObj.contractID = paramsObj.contract.contractID;
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.cards = Array.from(event.selected);
      paramsObj.sourcePID = event.payload.sourcePID;
      paramsObj.fromPID = this.game.ownPID;
      paramsObj.private = event.private;
      var snapshot = this.gameSnapshot();
      try {
         var JSONResult = await this.onGameState(snapshot, this.callContractAPI, "store", paramsObj).promise;
         if (this.contractID != JSONResult.result.contract.contractID) {
            console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
            console.dir(JSONResult);
            throw(new Error("Unexpected contract ID returned."));
         }
         try {
            this.updateBalances(JSONResult.result.contract);
         } catch (err) {
            this.game.debug(err, "err");
         }
      } catch (err) {
         this.game.debug(err, "err");
      }
   }

   /**
   * Event handler invoked when the associated {@link CypherPokerContract#game}
   * instance dispatches a {@link CypherPoker#event:gameend} event. This
   * currently causes an immediate submission of the keychain to the
   * contract via a "store" message.
   *
   * @param {Event} event A {@link CypherPoker#event:gameend} event object.
   *
   * @async
   * @private
   */
   async onGameEnd(event) {
      this.startContractTimeout();
      var paramsObj = new Object();
      paramsObj.type = "keychain";
      paramsObj.contract = this.history[0];
      paramsObj.contractID = paramsObj.contract.contractID;
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.keychain = Array.from(this.game.getPlayer(this.game.ownPID).keychain);
      paramsObj.fromPID = this.game.ownPID;
      //var snapshot = this.gameSnapshot();
      try {
         var JSONResult = await this.callContractAPI("store", paramsObj);
         if (JSONResult.error != undefined) {
            console.error (JSONResult.error);
            return;
         }
         if (this.contractID != JSONResult.result.contract.contractID) {
            console.error("Expecting contract ID \""+this.contractID+"\", got \""+JSONResult.result.contract.contractID+"\"");
            console.dir(JSONResult);
            throw(new Error("Unexpected contract ID returned."));
         }
         try {
            this.updateBalances(JSONResult.result.contract);
         } catch (err) {
            this.game.debug(err, "err");
         }
      } catch (err) {
         this.game.debug(err, "err");
      }
   }

   /**
   * Creates a deferred invocation action object based on a game snapshot (state).
   *
   * @param {Object} snapshot A game snapshot (state) to match to a contract
   * state in order to invoke &lt;code>functionRef&lt;/code>; for example, a snapshot
   * created using {@link CypherPokerContract#gameSnapshot}.
   * @param {Function} functionRef The &lt;b>asynchronous&lt;/b> function to invoke when the game
   * &lt;code>snapshot&lt;/code> (state) matches the contract state.
   * @param {*} params Any parameters to include with the function invocation.
   *
   * @return {Object} A deferred game state action object containing a game
   * &lt;code>snapshot&lt;/code>, &lt;code>invoke&lt;/code> object containing a deferred
   * &lt;code>func&lt;/code> function to invoke with &lt;code>params&lt;/code> parameters,
   * a &lt;code>promise&lt;/code> that will resolve when the &lt;code>snapshot&lt;/code>
   * matches the reported contract, and a &lt;code>complete&lt;/code> property
   * indicating if the action has completed (true) or not (false).
   * @private
   */
   onGameState(snapshot, functionRef, ...params) {
      var action = new Object();
      action.snapshot = snapshot;
      action.invoke = new Object();
      action.contract = this;
      action.invoke.func = functionRef;
      action.invoke.params = params;
      action.promise = new Promise((resolve, reject) => {
         //resolves or rejects in processDeferredActions
         action._resolve = resolve;
         action._reject = reject;
      })
      action.complete = false;
      this.deferredActions.push(action);
      if (this.history.length > 0) {
         this.processDeferredActions(this.history[0]);
      }
      return (action);
   }

   /**
   * Runs {@link CypherPokerContract#deferredActions} and executes the next un-executed action
   * if its game &lt;code>snapshot&lt;/code> matches the &lt;code>contract&lt;/code> state.
   *
   * @param {ContractObject} contract The (ideally) updated contract object to check against
   * {@link CypherPokerContract#deferredActions} for possible execution.
   *
   * @return {Promise} Resolves with the deferred action objects that were just executed. Will be an empty
   * array if no actions were executed.
   * @private
   */
   async processDeferredActions(contract){
      var actions = this.deferredActions;
      var previousAction = null;
      var completedActions = new Array();
      var incompletedActions = new Array();
      for (var count=0; count &lt; actions.length; count++) {
         var currentAction = actions[count];
         var exec = false;
         if (previousAction == null) {
            exec = true;
         }
         if (previousAction != null) {
            if (previousAction.complete == true) {
               exec = true;
            }
         }
         if ((currentAction.complete == false) &amp;&amp; (exec == true)) {
            //todo: investigate why states are not matching on second (and later) games
            //var snapshot = currentAction.snapshot;
            //var result = this.compare (contract, snapshot);
            //if ((result == 0) || (result == 2)) {
               var func = currentAction.invoke.func;
               var params = currentAction.invoke.params;
               var context = currentAction.contract;
               try {
                  currentAction.complete = true;
                  var fResult = await func.apply(context, params);
                  completedActions.push(currentAction);
                  this.game.debug ("CypherPokerContract: Contract action processed. Here's the response...");
                  this.game.debug (fResult, "dir");
                  currentAction._resolve(fResult);
               } catch (err) {
                  incompletedActions.push(currentAction);
                  this.game.debug(err, "err");
                  currentAction._reject(err);
               }
            //}
         } else {
            if (currentAction.complete == false) {
               incompletedActions.push(currentAction);
            }
         }
         previousAction = currentAction;
      }
      return (completedActions);
   }

   /**
   * Deteremines whether a function is asynchronous (async) or synchronous.
   *
   * @param {function} func The function to evaluate.
   *
   * @return {Boolean} True if the function is asynchronous, false if it's a
   * synchronous function or not a function.
   * @private
   */
   isAsync(func) {
      if (typeof(func) != "function") {
         return (false);
      }
      return (String(func).startsWith("async"));
   }

   /**
   * Sends an "agree" message to the contract API signalling our acceptance of
   * the contract rules. At this point the &lt;code>contract&lt;/code> parameter
   * should have been carefully examined for accuracy.
   *
   * @param {ContractObject} contract The contract associated with this instance
   * to agree to. The contract's owner is assumed to be the current dealer in the
   * {@link CypherPokerContract#game} instance.
   *
   * @return {ContractObject} The contract object that was agreed to, according to
   * the remote service.
   * @todo Compare input and output of function as a final verification
   * @private
   */
   async agreeToContract(contract) {
      this.game.debug ("CypherPokerContract: Agreeing to contract...");
      this.game.debug (contract, "dir");
      var paramsObj = new Object();
      paramsObj.ownerPID = this.game.getDealer().privateID;
      paramsObj.contractID = contract.contractID;
      var JSONResult = await this.callContractAPI("agree", paramsObj);
      if (JSONResult.error == undefined) {
         this.updateBalances(JSONResult.result.contract);
      } else {
         throw (new Error(JSONResult.error.message));
      }
      this.history.unshift(JSONResult.result.contract);
      return (JSONResult.result.contract);
   }

   /**
   * Updates the balances of the associated {@link CypherPokerContract#game} instance's
   * players from a provided contract data object.
   *
   * @param {Object} contractData The contract data object to use to update
   * player balances.
   * @param {Boolean} fatalFail=false If true, the function will throw an error on an update failure
   * (usually a value can't be converted). If false, errors are ignored.
   * @throws {Error} If a game balance is not of a convertible type or subsequently if an account
   * balance can't be converted. Note that an invalid game balance does not mean that the account
   * balance is valid because it's checked second. Only thrown if &lt;code>fataiFail=true&lt;/code>.
   * @private
   */
   updateBalances(contractData, fatalFail=false) {
      var contractPlayers = contractData.players;
      for (var count = 0; count &lt; contractPlayers.length; count++) {
         var contractPlayer = contractPlayers[count]; //player in contract
         var privateID = contractPlayer.privateID;
         var localPlayer = this.game.getPlayer(privateID); //player in game
         if ((typeof(contractPlayer.balance) == "string") || (typeof(contractPlayer.balance) == "number")) {
            localPlayer.balance = contractPlayer.balance;
         } else {
            try {
                  //balance may be a String-able instance
                  localPlayer.balance = contractPlayer.balance.toString();
            } catch (err) {
               if (fatalFail == true) {
                  throw (new Error("Player game balance for \""+privateID+"\" invalid (type: "+typeof(contractPlayer.balance)+"): "+contractPlayer.balance));
               }
            }
         }
         if ((typeof(contractPlayer.account) == "object") &amp;&amp; (contractPlayer.account != null)) {
            if ((typeof(contractPlayer.account.balance) == "string") || (typeof(contractPlayer.account.balance) == "number")) {
               if ((localPlayer.account == null) || (localPlayer.account == undefined)) {
                  localPlayer.account = new CypherPokerAccount(this.cypherpoker, contractPlayer.account);
               } else {
                  localPlayer.account.balance = contractPlayer.account.balance;
               }
            } else {
               try {
                  localPlayer.account.balance = contractPlayer.account.balance.toString();
               } catch (err) {
                  if (fatalFail == true) {
                     throw (new Error("Player account balance for \""+privateID+"\" invalid (type: "+typeof(contractPlayer.account.balance)+"): "+contractPlayer.account.balance));
                  }
               }
            }
         }
      }
   }

   /**
   * Asynchronously calls the contract API and returns the JSON-RPC 2.0 result / error
   * of the call.
   *
   * @param {String} action The contract API action to take. This parameter is appended
   * the &lt;code>params&lt;/code> object and will overwrite any &lt;code>action&lt;/code> property
   * included.
   * @param {Object} [params=null] The parameters to include with the remote function call.
   * If null, an empty object is created.
   * @param {String} [APIFunc="CP_SmartContract"] The remote API function to invoke.
   *
   * @return {Promise} The promise resolves with the parsed JSON-RPC 2.0 result or
   * error (native object) of the call. Currently there is no rejection state.
   * @private
   */
   async callContractAPI(action, params=null, APIFunc="CP_SmartContract") {
      var sendObj = new Object();
      if (params == null) {
         params = new Object();
      }
      for (var item in params) {
         sendObj[item] = params[item];
      }
      if (this.history.length > 0) {
         if (this.history[0].invalid == true) {
            throw (new Error("Contract is not valid!"));
         }
      }
      sendObj.action = action;
      sendObj.user_token = this.cypherpoker.p2p.userToken;
      sendObj.server_token = this.cypherpoker.p2p.serverToken;
      sendObj.account = this.game.getPlayer(this.game.ownPID).account.toObject(true);
      var requestID = "CP" + String(Math.random()).split(".")[1];
      var rpc_result = await RPC(APIFunc, sendObj, this.cypherpoker.p2p.webSocket, false, requestID);
      var result = JSON.parse(rpc_result.data);
      //since messages over web sockets are asynchronous the next immediate message may not be ours so:
      while (requestID != result.id) {
         rpc_result = await this.cypherpoker.p2p.webSocket.onEventPromise("message");
         result = JSON.parse(rpc_result.data);
         //we could include a max wait limit here
      }
      return (result);
   }

   /**
   * Verifies that a result object contains valid contract update data
   * intended for this instance and the associated {@link CypherPokerContract#game}
   * instance.
   *
   * @param {Object} resultObj The object to analyze, usually the &lt;code>result&lt;/code>
   * of a JSON-RPC 2.0 message.
   *
   * @return {Boolean} True if the result object has a valid contract update object
   * structure and is intended for this contract instance.
   * @private
   */
   verifyContractMessage(resultObj) {
      if ((typeof(resultObj.data) != "object") || (resultObj.data == null)) {
         return (false);
      }
      var data = resultObj.data;
      var contract = data.contract;
      var table = contract.table;
      if ((this.game == undefined) || (this.game == null)) {
         return (false);
      }
      if ((typeof(this.game.table) != "object") || (this.game.table == null)) {
         return (false);
      }
      if ((this.game.table.tableID != table.tableID) ||
         (this.game.table.tableName != table.tableName) ||
         (this.game.table.ownerPID != table.ownerPID)) {
            return (false);
      }
      var tableInfo = table.tableInfo;
      var gameTableInfo = this.game.table.tableInfo;
      if ((gameTableInfo.buyIn != tableInfo.buyIn) ||
         (gameTableInfo.bigBlind != tableInfo.bigBlind) ||
         (gameTableInfo.smallBlind != tableInfo.smallBlind)) {
            return (false);
      }
      var players = contract.players;
      var matchingPlayers = 0;
      for (var count = 0; count &lt; players.length; count++) {
         for (var count2 = 0; count2 &lt; this.game.players.length; count2++) {
            if (players[count].privateID == this.game.players[count2].privateID) {
               matchingPlayers++;
            }
         }
      }
      if (matchingPlayers != this.game.players.length) {
         return (false);
      }
      //other checks can be performed here
      return (true);
   }

   /**
   * Verifies that a result object contains the same contract ID as this
   * instance. This function should only be called after the result object
   * has been verified {@link CypherPokerContract#verifyContractMessage} and
   * the {@link CypherPokerContract#contractID} property has been set.
   *
   * @param {Object} resultObj The object to analyze, usually the &lt;code>result&lt;/code>
   * of a JSON-RPC 2.0 message.
   *
   * @return {Boolean} True if the result object's contract ID matches this
   * instances'.
   * @private
   */
   verifyContractID(resultObj) {
      var data = resultObj.data;
      if ((typeof(data.contract) != "object") || (data.contract == null)) {
         return (false);
      }
      var contract = data.contract;
      if (contract.contractID != this.contractID) {
         return (false);
      }
      return (true);
   }

   /**
   * Handles a server update message event dispatched by the communication
   * interface of the associated {@link CypherPokerContract#game} instance.
   *
   * @param {Event} event An "update" event dispatched by the communication interface.
   *
   * @private
   * @async
   */
   async handleUpdateMessage(event) {
      if (this.cypherpoker.isCPMsgEvent(event) == false) {
         //don't process any further
         return;
      }
      var resultObj = event.data.result;
      if (this.verifyContractMessage(resultObj) == false) {
         //either not a contract update message or not for this instance
         return;
      }
      if (resultObj.from != undefined) {
         var fromPID = resultObj.from; //peer-initiated
      } else {
         fromPID = null; //server-initiated
      }
      var contractObj = resultObj.data.contract;
      var messageType = resultObj.data.cpMsg;
      var contract = resultObj.data.contract;
      var table = contract.table;
      var players = contract.players;
      this.history.unshift(contractObj); //make sure to store contract in history!
      this.game.debug("CypherPokerContract.handleUpdateMessage("+event+") => \""+messageType+"\"");
      this.processDeferredActions(contractObj); //respond immediately on game state match
      switch (messageType) {
         case "contractnew":
            if (this.contractID == null) {
               this._contractID = contract.contractID;
               this.updateBalances(contract);
               var snapshot = this.gameSnapshot();
               this.onGameState(snapshot, this.agreeToContract, contract).promise.catch (err => {
                  this._contractID = null; //could not agree / contract is invalid
                  this.removeGameEventListeners();
                  this.game.debug(err, "err");
               });
               if (this.history[0].invalid != true) {
                  this.startContractTimeout();
               } else {
                  this.stopContractTimeout();
               }
            }
            break;
         case "contractagree":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            //note that contract owner (dealer) auto-agrees in addition to...
            this.game.debug ("Player "+fromPID+" has agreed to contract: "+contract.contractID);
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            if (this.history[0].invalid != true) {
               this.startContractTimeout();
            } else {
               this.stopContractTimeout();
            }
            break;
         case "contractencryptstore":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.game.debug ("Player "+fromPID+" has stored an encryption round to the contract:");
            this.game.debug (contract, "dir");
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            if (this.history[0].invalid != true) {
               this.startContractTimeout();
            } else {
               this.stopContractTimeout();
            }
            break;
         case "contractselectstore":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.game.debug ("Player "+fromPID+" has stored a card(s) selection to the contract:");
            this.game.debug (contract, "dir");
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            if (this.history[0].invalid != true) {
               this.startContractTimeout();
            } else {
               this.stopContractTimeout();
            }
            break;
         case "contractdecryptstore":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.game.debug ("Player "+fromPID+" has stored a decryption round to the contract:");
            this.game.debug (contract, "dir");
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            if (this.history[0].invalid != true) {
               this.startContractTimeout();
            } else {
               this.stopContractTimeout();
            }
            break;
         case "contractbet":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.game.debug ("Player "+fromPID+" has stored a bet or fold action to the contract:");
            this.game.debug (contract, "dir");
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            if (this.history[0].invalid != true) {
               this.startContractTimeout();
            } else {
               this.stopContractTimeout();
            }
            break;
         case "contractkeychainstore":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.game.debug ("Player "+fromPID+" has stored their keychain to the contract:");
            this.game.debug (contract, "dir");
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            this.startContractTimeout();
            break;
         case "contracttimeout":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.updateBalances(contract);
            this.processDeferredActions(contract);
            var event = new Event("timeout");
            event.contract = this;
            event.penalized = contract.penalty.penalized;
            this.dispatchEvent(event);
            this.stopContractTimeout();
            this.resetContractTimeout();
            break;
         case "contractend":
            if (this.verifyContractID(resultObj) == false) {
               //wrong contract ID
               return;
            }
            this.removeGameEventListeners();
            this.stopContractTimeout();
            this.resetContractTimeout();
            break;
         default:
            //not a recognized CypherPokerContract message type
            break;
      }
   }

}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CypherPoker.html">CypherPoker</a></li><li><a href="CypherPokerAccount.html">CypherPokerAccount</a></li><li><a href="CypherPokerAnalyzer.html">CypherPokerAnalyzer</a></li><li><a href="CypherPokerCard.html">CypherPokerCard</a></li><li><a href="CypherPokerContract.html">CypherPokerContract</a></li><li><a href="CypherPokerGame.html">CypherPokerGame</a></li><li><a href="CypherPokerPlayer.html">CypherPokerPlayer</a></li><li><a href="CypherPokerUI.html">CypherPokerUI</a></li><li><a href="SRACrypto.html">SRACrypto</a></li><li><a href="SRACryptoWorker.html">SRACryptoWorker</a></li><li><a href="WorkerHost.html">WorkerHost</a></li><li><a href="WSS.html">WSS</a></li></ul><h3>Events</h3><ul><li><a href="CypherPoker.html#event:newgame">newgame</a></li><li><a href="CypherPoker.html#event:start">start</a></li><li><a href="CypherPoker.html#event:tablejoin">tablejoin</a></li><li><a href="CypherPoker.html#event:tablejoinrequest">tablejoinrequest</a></li><li><a href="CypherPoker.html#event:tablejointimeout">tablejointimeout</a></li><li><a href="CypherPoker.html#event:tableleave">tableleave</a></li><li><a href="CypherPoker.html#event:tablemsg">tablemsg</a></li><li><a href="CypherPoker.html#event:tablenew">tablenew</a></li><li><a href="CypherPoker.html#event:tableready">tableready</a></li><li><a href="CypherPokerAnalyzer.html#event:analyzed">analyzed</a></li><li><a href="CypherPokerAnalyzer.html#event:analyzing">analyzing</a></li><li><a href="CypherPokerAnalyzer.html#event:scored">scored</a></li><li><a href="CypherPokerContract.html#event:timeout">timeout</a></li><li><a href="CypherPokerContract.html#event:timeoutinvalid">timeoutinvalid</a></li><li><a href="CypherPokerContract.html#event:timeoutstart">timeoutstart</a></li><li><a href="CypherPokerGame.html#event:gameanalyze">gameanalyze</a></li><li><a href="CypherPokerGame.html#event:gamebet">gamebet</a></li><li><a href="CypherPokerGame.html#event:gamebetplaced">gamebetplaced</a></li><li><a href="CypherPokerGame.html#event:gamecardsencrypt">gamecardsencrypt</a></li><li><a href="CypherPokerGame.html#event:gamedeal">gamedeal</a></li><li><a href="CypherPokerGame.html#event:gamedealmsg">gamedealmsg</a></li><li><a href="CypherPokerGame.html#event:gamedealprivate">gamedealprivate</a></li><li><a href="CypherPokerGame.html#event:gamedealpublic">gamedealpublic</a></li><li><a href="CypherPokerGame.html#event:gamedeck">gamedeck</a></li><li><a href="CypherPokerGame.html#event:gamedecrypt">gamedecrypt</a></li><li><a href="CypherPokerGame.html#event:gameend">gameend</a></li><li><a href="CypherPokerGame.html#event:gamehello">gamehello</a></li><li><a href="CypherPokerGame.html#event:gamekeypair">gamekeypair</a></li><li><a href="CypherPokerGame.html#event:gameparams">gameparams</a></li><li><a href="CypherPokerGame.html#event:gameplayerkeychain">gameplayerkeychain</a></li><li><a href="CypherPokerGame.html#event:gameplayerready">gameplayerready</a></li><li><a href="CypherPokerGame.html#event:gameready">gameready</a></li><li><a href="CypherPokerGame.html#event:gamerestart">gamerestart</a></li><li><a href="CypherPokerGame.html#event:gamescored">gamescored</a></li></ul><h3>Mixins</h3><ul><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="EventPromise.html">EventPromise</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RPC">RPC</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Oct 15 2018 17:34:05 GMT-0500 (GMT-05:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
